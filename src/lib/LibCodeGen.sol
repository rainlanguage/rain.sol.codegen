// SPDX-License-Identifier: LicenseRef-DCL-1.0
// SPDX-FileCopyrightText: Copyright (c) 2020 Rain Open Source Software Ltd
pragma solidity ^0.8.25;

import {Vm} from "forge-std/Vm.sol";
import {IOpcodeToolingV1} from "../interface/IOpcodeToolingV1.sol";
import {IParserToolingV1} from "../interface/IParserToolingV1.sol";
import {ISubParserToolingV1} from "../interface/ISubParserToolingV1.sol";
import {IIntegrityToolingV1} from "../interface/IIntegrityToolingV1.sol";
import {LibHexString} from "./LibHexString.sol";

/// @dev Maximum length of a line in the generated code. Important limit for
/// compatibility with formatters such as `foundry fmt`.
uint256 constant MAX_LINE_LENGTH = 120;

/// @dev Newline string used when a line exceeds the max length. Indentation
/// needs to match what formatters expect.
string constant NEWLINE_DUE_TO_MAX_LENGTH = "\n    ";

/// @title LibCodeGen
/// @notice Library for generating Solidity code snippets for contract function
/// pointers, code hashes, associated comments, etc. All snippets are returned
/// as strings that can be concatenated into complete Solidity files and written
/// to disk by the caller.
library LibCodeGen {
    /// The file prefix for autogenerated files outlines the license, pragma,
    /// and a note about the file being autogenerated. The pragma is ^ as the
    /// generated code is expected to be imported into some concrete contract
    /// with pragma = version.
    function filePrefix() internal pure returns (string memory) {
        //REUSE-IgnoreStart
        return string.concat(
            "// SPDX-License-Identifier: LicenseRef-DCL-1.0\n"
            "// SPDX-FileCopyrightText: Copyright (c) 2020 Rain Open Source Software Ltd\n"
            "pragma solidity ^0.8.25;\n\n",
            "// THIS FILE IS AUTOGENERATED BY ./script/BuildPointers.sol\n\n"
            "// This file is committed to the repository because there is a circular\n"
            "// dependency between the contract and its pointers file. The contract\n"
            "// needs the pointers file to exist so that it can compile, and the pointers\n"
            "// file needs the contract to exist so that it can be compiled.\n"
        );
        //REUSE-IgnoreEnd
    }

    /// Puts the hash of the bytecode of some contract instance into a constant
    /// string. Often used to ensure that the deployed bytecode matches the
    /// expected bytecode.
    /// @param vm The Vm instance for file operations.
    /// @param instance The address of the contract instance whose bytecode
    /// hash is to be computed.
    /// @return A string containing the Solidity code for the bytecode hash
    /// constant.
    function bytecodeHashConstantString(Vm vm, address instance) internal view returns (string memory) {
        bytes32 bytecodeHash;
        assembly {
            bytecodeHash := extcodehash(instance)
        }
        return string.concat(
            "\n",
            "/// @dev Hash of the known bytecode.\n",
            "bytes32 constant BYTECODE_HASH = bytes32(",
            vm.toString(bytecodeHash),
            ");\n"
        );
    }

    /// Puts the opcode function pointers used by the interpreter into a
    /// constant string.
    /// @param vm The Vm instance for file operations.
    /// @param interpreter The interpreter tooling instance to get the
    /// function pointers from.
    /// @return A string containing the Solidity code for the opcode function
    /// pointers constant.
    function opcodeFunctionPointersConstantString(Vm vm, IOpcodeToolingV1 interpreter)
        internal
        view
        returns (string memory)
    {
        return bytesConstantString(
            vm,
            string.concat(
                "/// @dev The function pointers known to the interpreter for dynamic dispatch.\n",
                "/// By setting these as a constant they can be inlined into the interpreter\n",
                "/// and loaded at eval time for very low gas (~100) due to the compiler\n",
                "/// optimising it to a single `codecopy` to build the in memory bytes array."
            ),
            "OPCODE_FUNCTION_POINTERS",
            interpreter.buildOpcodeFunctionPointers()
        );
    }

    /// Puts the literal parser function pointers used by the parser into a
    /// constant string.
    /// @param vm The Vm instance for file operations.
    /// @param instance The parser tooling instance to get the function pointers
    /// from.
    /// @return A string containing the Solidity code for the literal parser
    /// function pointers constant.
    function literalParserFunctionPointersConstantString(Vm vm, IParserToolingV1 instance)
        internal
        pure
        returns (string memory)
    {
        return bytesConstantString(
            vm,
            string.concat(
                "/// @dev Every two bytes is a function pointer for a literal parser.\n",
                "/// Literal dispatches are determined by the first byte(s) of the literal\n",
                "/// rather than a full word lookup, and are done with simple conditional\n",
                "/// jumps as the possibilities are limited compared to the number of words we\n",
                "/// have."
            ),
            "LITERAL_PARSER_FUNCTION_POINTERS",
            instance.buildLiteralParserFunctionPointers()
        );
    }

    /// Puts the operand handler function pointers used by the parser into a
    /// constant string.
    /// @param vm The Vm instance for file operations.
    /// @param instance The parser tooling instance to get the function pointers
    /// from.
    /// @return A string containing the Solidity code for the operand handler
    /// function pointers constant.
    function operandHandlerFunctionPointersConstantString(Vm vm, IParserToolingV1 instance)
        internal
        pure
        returns (string memory)
    {
        return bytesConstantString(
            vm,
            string.concat(
                "/// @dev Every two bytes is a function pointer for an operand handler.\n",
                "/// These positional indexes all map to the same indexes looked up in the parse\n",
                "/// meta."
            ),
            "OPERAND_HANDLER_FUNCTION_POINTERS",
            instance.buildOperandHandlerFunctionPointers()
        );
    }

    /// Puts the sub parser word parser function pointers used by the sub parser
    /// into a constant string.
    /// @param vm The Vm instance for file operations.
    /// @param subParser The sub parser tooling instance to get the function
    /// pointers from.
    /// @return A string containing the Solidity code for the sub parser word
    /// parsers constant.
    function subParserWordParsersConstantString(Vm vm, ISubParserToolingV1 subParser)
        internal
        pure
        returns (string memory)
    {
        return bytesConstantString(
            vm,
            string.concat(
                "/// @dev The function pointers for the sub parser functions that produce the\n",
                "/// bytecode that this contract knows about. This is both constructing the subParser\n",
                "/// bytecode that dials back into this contract at eval time, and mapping\n",
                "/// to things that happen entirely on the interpreter such as well known\n",
                "/// constants and references to the context grid."
            ),
            "SUB_PARSER_WORD_PARSERS",
            subParser.buildSubParserWordParsers()
        );
    }

    /// Puts the integrity check function pointers used by the integrity tooling
    /// into a constant string.
    /// @param vm The Vm instance for file operations.
    /// @param deployer The integrity tooling instance to get the function
    /// pointers from.
    /// @return A string containing the Solidity code for the integrity check
    /// function pointers constant.
    function integrityFunctionPointersConstantString(Vm vm, IIntegrityToolingV1 deployer)
        internal
        view
        returns (string memory)
    {
        return bytesConstantString(
            vm,
            "/// @dev The function pointers for the integrity check fns.",
            "INTEGRITY_FUNCTION_POINTERS",
            deployer.buildIntegrityFunctionPointers()
        );
    }

    /// Puts the hash of the meta that describes the contract into a constant
    /// string.
    /// @param vm The Vm instance for file operations.
    /// @param name The name of the contract whose meta hash is to be computed.
    /// @return A string containing the Solidity code for the described by meta
    /// hash constant.
    function describedByMetaHashConstantString(Vm vm, string memory name) internal view returns (string memory) {
        bytes memory describedByMeta = vm.readFileBinary(string.concat("meta/", name, ".rain.meta"));
        return string.concat(
            "\n",
            "/// @dev The hash of the meta that describes the contract.\n",
            "bytes32 constant DESCRIBED_BY_META_HASH = bytes32(",
            vm.toString(keccak256(describedByMeta)),
            ");\n"
        );
    }

    /// Generates a Solidity bytes constant declaration string. Needs special
    /// handling to be formatted nicely due to potential length of hex data and
    /// constant name.
    /// @param vm The Vm instance for file operations.
    /// @param comment The comment to include above the constant declaration.
    /// @param name The name of the constant.
    /// @param data The bytes data for the constant.
    /// @return A string containing the Solidity code for the bytes constant.
    function bytesConstantString(Vm vm, string memory comment, string memory name, bytes memory data)
        internal
        pure
        returns (string memory)
    {
        string memory hexData = LibHexString.bytesToHex(vm, data);
        return string.concat(
            "\n",
            comment,
            "\nbytes constant ",
            name,
            " =",
            17 + bytes(name).length + 6 + bytes(hexData).length + 2 > MAX_LINE_LENGTH ? NEWLINE_DUE_TO_MAX_LENGTH : " ",
            "hex\"",
            hexData,
            "\";\n"
        );
    }

    /// Generates a Solidity uint8 constant declaration string. Needs special
    /// handling to be formatted nicely due to potential length of constant name.
    /// @param vm The Vm instance for file operations.
    /// @param comment The comment to include above the constant declaration.
    /// @param name The name of the constant.
    /// @param data The uint8 data for the constant.
    /// @return A string containing the Solidity code for the uint8 constant.
    function uint8ConstantString(Vm vm, string memory comment, string memory name, uint8 data)
        internal
        pure
        returns (string memory)
    {
        return string.concat(
            "\n",
            comment,
            "\nuint8 constant ",
            name,
            " =",
            17 + bytes(name).length + 6 + 3 + 2 > MAX_LINE_LENGTH ? NEWLINE_DUE_TO_MAX_LENGTH : " ",
            vm.toString(data),
            ";\n"
        );
    }
}
